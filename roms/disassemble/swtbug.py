#!/usr/bin/env python3

import info

l = info.LabelList()

l.processor = '6800'
l.source = 'e000.s19'

l.add(0xA000, 'irq', type='rmb:2', data=2, comment=':irq pointer')
l.add(0xA002, 'bega', type='rmb:2', data=2, comment=':beginning addr pnch')
l.add(0xA004, 'enda', type='rmb:2', data=2, comment=':ending addr pnch')
l.add(0xA006, 'nmi', type='rmb:2', data=2, comment=':nmi interrupt vector')
l.add(0xA008, 'sp', type='rmb:1', data=1, comment=':s high')
l.add(0xA009, type='rmb:1', data=1, comment=':s low')
l.add(0xA00A, 'poradd', type='rmb:2', data=2, comment=':port address')
l.add(0xA00C, 'porech', type='rmb:1', data=1, comment=':echo on/off flag')
l.add(0xA00D, 'xhi', type='rmb:1', data=1, comment=':xreg high')
l.add(0xA00E, 'xlow', type='rmb:1', data=1, comment=':xreg low')
l.add(0xA00F, 'cksm', type='rmb:1', data=1, comment=':checksum')
l.add(0xA010, 'xtemp', type='rmb:2', data=2, comment=':x-reg temp stge')
l.add(0xA012, 'swijmp', type='rmb:2', data=2, comment=':swi jump vector')

l.add(0xA044, 'tw', type='used', comment=':temporary storage')
l.add(0xA046, 'temp', type='used', comment=':temporary storage')
l.add(0xA047, 'bytect', type='used', comment=':bytect and mcont temp.')
l.add(0x8004, 'ctlpor', type='used', comment=':control port address')
l.add(0xC000, 'prom', type='used', comment=':jump to prom address')

l.add(0xA014, 'bkpt', type='rmb:2', data=2, comment=':breakpoint address')
l.add(0xA016, 'bklst', type='rmb:1', data=1, comment=':breakpoint data')

l.add(0xa042, 'stack', type='rmb:1', data=1, comment=':swtbug stack')

l.add(0xE000, 'irqv', comment="i/o interrupt sequence")
l.add(0xE005, 'jump', comment='jump to user program')

l.add(0xE009, 'cursor', type='byte:3', data=3, comment=':ct-1024 cursor control')

l.add(0xE00C, 'load', comment='ascii loading routine:reader on, dis echo, get p#')
l.add(0xE00F, 'load3')
l.add(0xE011, type='char')
l.add(0xe013, comment=':1st char not s')
l.add(0xe015, comment=':read char')
l.add(0xE017, type='char')
l.add(0xe01b, type='char')
l.add(0xe01d, comment=':2nd char not 1')
l.add(0xe01f, comment=':zero checksum')
l.add(0xe022, comment=':read byte')
l.add(0xe026, comment=':byte count')
l.add(0xE029, comment='build address')
l.add(0xe02b, 'load11', comment="store data")
l.add(0xe030, comment=':zero byte count')
l.add(0xe032, comment=':store data')
l.add(0xe034, comment=':data stored?')
l.add(0xe03b, 'load15')
l.add(0xe040, 'load19', type='char')
l.add(0xe044, 'load21')
l.add(0xE047, 'baddr', comment="build address:read 2 frames")
l.add(0xe051, comment=':load ixr with number')
l.add(0xe055, 'byte', comment='input byte (two frames):get hex char')
l.add(0xe057, 'byte1')
l.add(0xe067, 'outhl', comment=' :out hex left bcd digit')
l.add(0xe06b, 'outhr', comment=':out hex right bcd digit')
l.add(0xe075, 'outch', comment="output one char")
l.add(0xe078, 'inch')
l.add(0xe07b, 'pdata2', comment="print data pointed to by x reg")
l.add(0xe07e, 'pdata1')
l.add(0xe084, comment=':stop on hex 04')
l.add(0xe085, 'c1', comment=' ')
l.add(0xe088, 'change', comment='memory examine and change')
l.add(0xe08a, 'cha51')
l.add(0xe08d, comment=':c/r l/f')
l.add(0xe092, comment=':print address')
l.add(0xe097, comment=':print old data')
l.add(0xe099, comment=':output space')
l.add(0xe09b, 'anoth', comment=':input char')
l.add(0xE0A5, type='char')
l.add(0xe0aa, 'inhex', comment="input hex character")
l.add(0xe0ac, 'inhex1')
l.add(0xe0b6, comment=':not hex')
l.add(0xe0ba, comment=':not hex')
l.add(0xe0be, 'in2hg')
l.add(0xe0bf, 'out2h', comment=' :output 2 hex char')
l.add(0xe0c1, 'out2ha', comment=":out left hex char")
l.add(0xe0c6, comment=":output right hext char")
l.add(0xe0c8, 'out4hs', comment=" :output 4 hex char + space")
l.add(0xE0CA, 'out2hs', comment=":output 2 hex char + space")
l.add(0xE0CC, 'outs', comment=" :space")

l.add(0xe0d0, 'start', comment='enter power on sequence')
l.add(0xe0d3, comment=":branch for address compatibil")
l.add(0xE0D5, 'al3', "part of memory examine and change")
l.add(0xe0de, 'sk1')
l.add(0xe0e3, 'eoe3', comment=' :branch for mikbug equiv. cont')
l.add(0xe0e5, 'al4', comment=' ')
l.add(0xE0F3, comment=':change memory')
l.add(0xe0f7, comment=':did change')
l.add(0xe0f9, comment=":didn't change")
l.add(0xe0fc, 'c3')
l.add(0xe101, 'al1', comment="continue powerup sequence:init target stack ptr")
l.add(0xe109, comment='configure for pia and see if ok')
l.add(0xe10c, comment=':init pia')
l.add(0xe115, comment=' :bra for biload')
l.add(0xe117, 'al2', comment=' ')
l.add(0xe119, comment='initialize as acia:acia master reset')

l.add(0xe123, 'sf0', comment='enter from software interrupt')
l.add(0xe124, 'sfe1', comment=':save targets stack pointer')
l.add(0xe127, comment='decrement p counter')
l.add(0xe12e, 'sf0x')
l.add(0xe130, 'print', comment='print contents of stack.')
l.add(0xe13a, comment=':cond codes')
l.add(0xe13c, comment=':acc b')
l.add(0xe13e, comment=':acc a')
l.add(0xe140, comment=':ixr')
l.add(0xe142, comment=':pgm counter')
l.add(0xe147, comment=':stack pointer')
l.add(0xE14A, 'swtctl')
l.add(0xe152, 'contrl', comment=' :set contrl stack pointer')
l.add(0xe155, comment=':reset to control port')
l.add(0xe15b, comment=':turn echo on')
l.add(0xe15e, comment=':get port # and type')
l.add(0xe162, comment=':set pia echo on if mp-c inter')
l.add(0xe165, 'pof1', comment=':turn punch off')
l.add(0xe168, comment=':turn reader off')
l.add(0xe16b, 'contr1')

l.add(0xe173, 'look', comment='command lookup routine')
l.add(0xe176, 'over')
l.add(0xe17a, comment=':skip space')
l.add(0xe181, 'sk3')
l.add(0xe189, 'swtl1')

l.add(0xe18b, 'sfe', comment='software interrupt entry point:jump to vectored software int')

l.add(0xe190, 's9', data=3, type="char:3", comment=" :end of tape")
l.add(0xe193, 'mtape1', data=9, type="char:9", comment=" :punch format")
l.add(0xe19c, 'mcloff', data=1, type="char:1", comment=':reader off')
l.add(0xe19d, 'mcl', data=8, type="char:8")

l.add(0xe1a5, 'eia5', ' :binary loader input')

l.add(0xe1a7, 'nmiv', comment='nmi sequence:get nmi vector')

l.add(0xe1ac, 'ineee', comment=" ")

l.add(0xe1ae, 'search,', comment='byte search routine:get top address')
l.add(0xe1b4, comment=':get bottom address')
l.add(0xe1b7, comment=':get byte to search for')
l.add(0xe1bb, 'ove')
l.add(0xe1c5, 'pnt')

l.add(0xe1d0, 'goto', comment='got to user program routine')
l.add(0xe1d1, 'outeee')

l.add(0xe1d3, 'SAVGET', comment='save ixr and load ixr with correct;port number and test for type:store index register')
l.add(0xe1d6, 'GETPT1', comment=":same but don't save x")
l.add(0xe1d9, 'ISACIA', comment=":check if current ")

l.add(0xe1e0, 'skp0', comment="continuation of search routine")
l.add(0xe1e6, 'incr1')
l.add(0xe1ee, 'ineee1', comment=" :input 8 bit character")
l.add(0xe1f0, type='binary', comment=":get rid of parity bit")
l.add(0xe1f3, 'bild', comment=' :fix up stack when using')
l.add(0xe1f4, comment=':binary loader on swtpc tapes')

l.add(0xe1f6, 'inch8', comment='input one char into acc b:save acc b')
l.add(0xe1f7, comment=':save ixr, get port# and type')
l.add(0xe1f9, comment=':input from pia of not')
l.add(0xe1fb, comment=':reconfig for 8 bit, 1 sb')
l.add(0xe1ff, 'aciain')
l.add(0xe202, comment=":not ready")
l.add(0xe204, comment=':load char')
l.add(0xe209, comment=':echo')
l.add(0xe20b, comment=":don't echo")

l.add(0xe20d, 'outeee1', comment='output one character:save acc b')

l.add(0xe212, 'aciout', comment=' ')
l.add(0xe216, 'aciou1')
l.add(0xe21a, comment=':acia not ready')
l.add(0xe21c, comment=':output character')
l.add(0xe21e, 'res', comment=":restore acc b")

l.add(0xe223, 'in1', comment="pia input routine:look for start bit")
l.add(0xe227, comment=':delay half bit time')
l.add(0xe229, comment=':set del for full bit time')
l.add(0xe22d, comment=':set up cntr with 8')
l.add(0xe22e, 'in3', comment=':wait one char time')
l.add(0xe237, comment=':wait for stop bit')
l.add(0xe239, comment=':is echo desired?')
l.add(0xe23c, comment=':echo')
l.add(0xe23e, comment=':restore ixr, accb')

l.add(0xe240, 'iout', comment="pia output routine:delay one half bit time")
l.add(0xe242, comment=':set up counter')
l.add(0xe244, comment=':set start bit')
l.add(0xe246, comment=':start timer')
l.add(0xe248, 'out1', comment=':delay one bit time')
l.add(0xe24a, comment=':put out one data bit')
l.add(0xe24d, comment=':shift in next bit')
l.add(0xe24e, comment=':decrement counter')
l.add(0xe24f, comment=':test for 0')
l.add(0xe251, 'iout2', comment=':test for stop bits')
l.add(0xe253, comment=':shift bit to sign')
l.add(0xe254, comment=':bra for 1 stop bit')
l.add(0xe256, comment=':delay for stop bits')
l.add(0xe25a, 'del', comment=':is time up')
l.add(0xe25e, 'de', comment=':reset timer')
l.add(0xe263, 'ddl', comment=' :half bit delay')
l.add(0xe265, 'ddl1')

l.add(0xe269, 'optl', comment="optional port routine")
l.add(0xa00b, 'poradd+1', comment=':set i/o address for 0x800')
l.add(0xe26c, comment=':set i/o address for $8000')
l.add(0xe272, comment=":initialize pia")
l.add(0xe274, comment=":set echo")
l.add(0xe276, comment=':P, L or E')
l.add(0xe27a, comment=":look at table for e, l, p")

l.add(0xe27d, 'piaech', comment=" :set ddr")
l.add(0xe283, 'noopt')
l.add(0xe284, 'piaini', comment="pia initialisation routine:set ddr")

l.add(0xe28f, 'delay', comment="general purpose delay loop", type="const")
l.add(0xe292, 'delay1')

l.add(0xe298, 'clear', comment="clear screen for ct-1024 type terminals")
l.add(0xe29e, comment=":delay")
l.add(0xe2a0, "rdoff1")

l.add(0xe2a5, 'break', comment="breakpoint entering routine")
l.add(0xe2a8, comment=":breakpoints already in use?")
l.add(0xe2ae, 'break0')
l.add(0xe2c7, 'inuse')

l.add(0xe2d4, 'swiset', comment=' :fix  power up interrupt')
l.add(0xa043, 'stack+1')
l.add(0xe2df, 'sto')
l.add(0xe2e2, 'sto1')
l.add(0xe2e5, 'stortn')

#### UNKNOWN #####
l.add(0xe2e6, 'unk1', comment="_unknown")

l.add(0xe2ed, 'do_t', comment="handle t command")

l.add(0xe2f2, 'pnchs9', comment="format end of tape with pgm. ctr. and s9", type='const')
l.add(0xe2f9, type='const')
l.add(0xe301, 'pdat')
l.add(0xe304, 'pofc4')
l.add(0xe308, 'c4')

l.add(0xe30b, 'RDON', comment=' :disable echo for acia')
l.add(0xe31b, 'rtnn')

l.add(0xe31c, 'rdoff', comment=" :turn reader off")
l.add(0xe320, 'PNCHON', comment=" ")
l.add(0xe324, 'pnchof', comment=" ")
l.add(0xe328, 'strobe', comment='pia strobing routine for punch/read on/off')

l.add(0xe32f, 'punch', comment="punch from beginning address (bega) thru;ending address (enda)")
l.add(0xe332, 'punch2')
l.add(0xe337, 'pun11')
l.add(0xa005, 'enda+1')
l.add(0xa045, 'tw+1')

l.add(0xe352, 'pun22')
l.add(0xe35d, 'pun23')
l.add(0xe371, comment="punch c/r l/f nulls s1")

l.add(0xE378, comment="punch frame count")
l.add(0xe37b, comment=":punch 2 hex characters")
l.add(0xe37d, comment="punch address")
l.add(0xE384, comment="punch data")
l.add(0xe387, 'pun32', comment=":punch one byte")
l.add(0xe394, comment=":punch checksum")
l.add(0xe396, comment=":restore stack")


l.add(0xe3af, 'PUNT2')

l.add(0xe3bf, 'B_INPUT', comment="read char and count checksum:read char")
l.add(0xe3c2, comment=':and add char to cksm')


l.add(0xe410, data=3, type='char')
l.add(0xe413, data=3, type='char')

l.add(0xe3ca, "BILOAD", comment="Binary Load")
l.add(0xe3cd, 'B_OVER')
l.add(0xe3cf, type="char")
l.add(0xe3d5, type="char")
l.add(0xe3d9, type="char")


#### the end ####

for a in range(0xe416, 0xe43c, 3):
    l.add(a, data=1, type='char')
    l.add(a+1, data=2, type="word")

l.add(0xe416, 'table', comment="command table:goto")
l.add(0xe419, comment=':memory exam and change')
l.add(0xe41c, comment=':byte search')
l.add(0xe41f, comment=':register dump')
l.add(0xe422, comment=":jump")
l.add(0xe425, comment=':clear screen')
l.add(0xe428, comment=':breakpoint')
l.add(0xe42b, comment=':optional port')
l.add(0xe42e, 'table1', comment=':ascii punch')
l.add(0xe431, comment=':ascii load')
l.add(0xe434, comment=':end of tape')
l.add(0xe437, comment=':_unknown')
l.add(0xe43a, "table3", comment=":_unknown")
l.add(0xe43d, '_tabend+3')


print(l)
